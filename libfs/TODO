-thread safety for MFS mutable directory inode
-concurrent namespace operations (mkdir, rmdir, link, unlink, rename)
-generic namemap: to be used by directory inodes and mount point pseudo-inodes
  - parameterized using a hashfunction (functor)
  - extend the hashtable interface to take the result of the hash-function as a hint 
    and verify that the hash is correct. is it cheaper to verify?
-readdir
-factories and storage manager for persistent objects
-factories for volatile objects
-files
-journal

================
-factory for superblock 
   - create superblock given a persistent superblock
-factory for inodes 
   - create inodes given a persistent inode


factories for persistent structures
 - to be used by the storage manager so we need a common interface
   to the structures. 
 - structures also need to use the same smgr interface to construct 
   instances. 
 


Optimizations:
==============

// TODO: optimize immutable inodes (e.g. for lookup)
// check ino if in cache otherwise return immutable
// if ino in cache then return mutable
// how about race: someone gets immutable but someone gets mutable
// and modifies. other doesn't see the modification.
// you should provide an easy way to check whether immutable inode
// is still valid. Here is a quick check that should work nicely in
// absence of contention (design point case):
//
// For example, GetInode should:
// -If asked for immutable inode then user should provide an Inode to wrap it in.
// -If asked for immutable inode then a mutable one exists in my cache then I won't provide it to you 
// -If asked for mutable inode then I will provide you with an Inode, which I will
//  also be responsible for deallocating when its refcount drops to 0


mfs/client/dir_inode.c
// TODO: perhaps it makes sense to cache persistent entries to avoid
// the second lookup (persistent inode lookup) for entries that have
// already been looked up in the past. But the benefit might not be much because
// it further slows down lookups as we need to insert an entry in the cache. 
 
client/namespace.cc
//TODO: Optimization: When resolving a pathname (Namex), use LookupFast API 
// instead of Lookup and revert to Lookup only when the inode is mutated
//TODO: optimization: when namex uses immutable for lookup, nameiparent should be able
//to ask for a mutable inode


client/imap.h
//TODO: USe a timestamp counter to signal to clients that an
// immutable inode mapping they hold may be invalid (because someone
// inserted a mutable one)
	

